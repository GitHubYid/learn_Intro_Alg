find_max_crossing_sumarray(A, low, mid, high)
    left_sum = -infinite
    sum = 0
    for i=mid downto low        # 找到mid到low的最大组合和
        sum = sum + A[i]
        if sum > left_sum
            left_sum = sum
            max_left = i        # 最大子数组的左边界
            
    right_sum = -infinite   
    sum = 0
    for i = mid+1 to high       # 找到mid+1到high的最大组合和
        sum = sum +A[i]
        if sum > right_sum
            right_sum = sum
            max_right = i       # 最大子数组的右边界
            
    return (max_left, max_right, left_sum+right_sum)
            
    